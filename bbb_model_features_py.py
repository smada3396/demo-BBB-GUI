# -*- coding: utf-8 -*-
"""bbb_model/features.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rqny2wr_srdvvZiNp7GxovNUCGvQBOLD
"""

import math
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors


def canonicalize_smiles(smiles: str) -> Optional[str]:
    if not isinstance(smiles, str) or not smiles.strip():
        return None
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        return Chem.MolToSmiles(mol, canonical=True)
    except Exception:
        return None


def mol_from_smiles(smiles: str) -> Optional[Chem.Mol]:
    try:
        mol = Chem.MolFromSmiles(smiles)
        return mol
    except Exception:
        return None


def rdkit_descriptor_names() -> List[str]:
    # RDKit built-in descriptor list
    return [name for name, _fn in Descriptors._descList]


def compute_rdkit_descriptors(smiles_list: List[str]) -> pd.DataFrame:
    """
    Returns a DataFrame of RDKit descriptors.
    Rows align with smiles_list (including invalid; invalid rows become NaN then filled).
    """
    names_fns = Descriptors._descList
    names = [n for n, _ in names_fns]

    rows = []
    for smi in smiles_list:
        mol = mol_from_smiles(smi)
        if mol is None:
            rows.append([np.nan] * len(names))
            continue
        vals = []
        for _name, fn in names_fns:
            try:
                v = fn(mol)
                # guard against inf
                if v is None or (isinstance(v, float) and (math.isinf(v) or math.isnan(v))):
                    v = np.nan
                vals.append(v)
            except Exception:
                vals.append(np.nan)
        rows.append(vals)

    df = pd.DataFrame(rows, columns=names)
    # Fill NaN with column medians for stability (tree models handle this, but keep clean)
    for c in df.columns:
        med = df[c].median()
        if np.isnan(med):
            med = 0.0
        df[c] = df[c].fillna(med)
    return df


def variance_filter(df: pd.DataFrame, min_var: float = 1e-12) -> pd.DataFrame:
    variances = df.var(axis=0)
    keep = variances[variances > min_var].index.tolist()
    return df[keep]


def correlation_prune(df: pd.DataFrame, threshold: float = 0.95) -> pd.DataFrame:
    """
    Remove one feature from each pair with |corr| > threshold (keeps earlier columns).
    """
    corr = df.corr().abs()
    upper = corr.where(np.triu(np.ones(corr.shape), k=1).astype(bool))
    drop_cols = [col for col in upper.columns if any(upper[col] > threshold)]
    return df.drop(columns=drop_cols, errors="ignore")


def make_descriptor_matrix(
    smiles: List[str],
    *,
    do_variance_filter: bool = True,
    do_corr_prune: bool = True,
    corr_threshold: float = 0.95,
) -> pd.DataFrame:
    X = compute_rdkit_descriptors(smiles)
    if do_variance_filter:
        X = variance_filter(X)
    if do_corr_prune:
        X = correlation_prune(X, threshold=corr_threshold)
    return X